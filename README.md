# Qake

A C/C++ project generator and high-level interface to GNU Make. Pronounced “cake” or “quake”.

It provides a simple way to generate a project and its Makefile. It does not provide anything beyond that. If you would like, you can use Qake as a starting point to generate your Makefile: see `--generate`.

Licensed under the GPL v3.0.

This is my project in C++ so don’t judge too harshly :)

## Building

Since Qake is a build system, it can build itself. However, a Makefile identical to the one generated by Qake is provided for convenience. To use this Makefile, it is necessary to provide `-f Makefile.bootstrap` as arguments to `make`.

```bash
# if you don’t have Qake
make -f Makefile.bootstrap build

# if you have Qake
qake build
```

## Usage

### `-I`, `--init`

Initialize a new project in this directory. Requires an interactive terminal.

You can choose to get the template `Qakefile.toml` verbatim, or to answer some questions such as project name and get a more tailored (but uncommented) config.

Both choices also create the basic directories `src`, `include`, and `sysinc`.

### `-g`, `--generate`

Generate a Makefile based on the Qakefile. This command is only necessary if you would like to have the intermediary Makefile for some reason; for example, to provide a Makefile for people that don’t have Qake.

The generated Makefile does not depend on any of the structure of the codebase. In other words, Qake performs no analysis of the codebase in order to generate the Makefile. As a result of this, most of the time you can generate a Makefile and continue to use it indefinitely. The only time you need to regenerate is if you change the configuration.

IMPORTANT: if you rename the directories, you will need to change the entries in the Qakefile, and vice versa. No automatic migration is provided.

### As an interface to `make`

When neither of the above options is provided, Qake forwards the options provided to `make`. Thus usage such as `qake build` or `qake clean` is equivalent to running `make` with those subcommands, using the generated Makefile. You can also provide options such as `--always-make`.

`example` is provided where you can test these commands.

Qake Makefiles contain phony targets `build` and `clean`. The generated Makefile’s default target is `build`, so just `qake` is the same as `qake build`.

### Universal Options

- `-f`, `--force`: Do not ask questions such as whether to overwrite existing files.
- `-p`, `--project`: Specify the path of the Qakefile. Defaults to `Qakefile.toml` in the current directory

## Project Config

### How to read type specifications

- `*` = required
- `T[]` = list of `T`
- `T{}` = table of with key of string and value of `T`.

### `_config_version` number*

This is used internally to provide backwards compatibility.

### `project.target` string*

Required. The name of the binary in the dist folder.

### `project.type` string

Can be `executable`, `shared`, or `static`. The default is `executable`.

### `project.language`: string

Can be `c` or `c++`. The default is `c`.

### `build.binary_suffix`: string

Appended to `project.target`. Should include the dot in the extension. The default depends on `project.type`:

- `executable`: ``
- `shared`: `.so`
- `static`: `.a`

### `build.cc`: string

The C compiler. The default depends on `project.language`:

- `c`: `gcc`
- `c++`: `g++`

### `build.standard`: string*

Required. The C/C++ standard, e.g., `gnu++17`.

### `build.optimize`: boolean

Whether to optimize the build with `-O2`. Default `true`.

### `build.use_dependencies`: boolean

Whether to use GCC’s dependency calculation. Default `true`.

If this is `false`, every C/C++ source will depend on every header. However, in some cases this dependency detection can cause false negatives in which case you may need to use `--always-make`, or specify the C file to rebuild on the command line.

### `build.pic`: boolean

Whether to generate position-independent code. Default `true`.

The flags that are added depend on the project type: PIC flags for a library and PIE flags for an executable.

### `build._flags`: string[]

Allows you to add flags directly to the compilation process. Default `[]` (no extra flags).

### `build.warnings`: bool{}

A table where the keys represent warnings and the values represent whether to enable (`true`) or disable (`false`). Enabling `x` means adding `-Wx`, while disabling means adding `-Wno-x`. Don’t use `no-...` as a key.

### `build.features`: bool{}

Same as `build.warnings` but for features, added with `-f...` or `-fno-...`. As with `build.warnings`, don’t use `no-...` as a key.

### `dependencies.libraries`: string[]

Libraries to link with. Added with `-l...`. Default `[]`.

### `dependencies.packages`: string[]

Use `pkg-config` to generate the libraries and includes for packages. Naturally using this will require that you have `pkg-config`. If you leave it empty then `pkg-config` is not required. Default `[]`.

### `dependencies.include_dirs`: string[]

System directories for system include files (-isystem flag). Differs from the project’s system include directory in that these are pre-existing directories from the system (e.g., `/usr/include/foobar`), whereas the project's system include directory refers to a place for actual header files provided by the project (as opposed to the system).

In other words, if you have a header installed on the system that doesn’t support `pkg-config` and want to use it, use this. If you want to provide a header but include it with angle brackets in the source code, put it in the system include directory (named by `directories.system_include`).

### `directories.objects`: string

Directory for unlinked object files, used for incremental builds. Default `obj`.

### `directories.source`: string

Directory for source files. Default `src`.

### `directories.include`: string

Directory for header files accessed with quotes. Default `include`.

### `directories.system_include`: string

Directory for header files accessed with angle brackets. Default `sysinc`.

See `dependencies.include_dirs` for information on the difference therebetween.

### `directories.dist`: string

Directory for final product (executable/library). Default `dist`.

### `directories.dependencies`: string

Directory for CC-generated dependencies, used for incremental builds. Default `deps`.
